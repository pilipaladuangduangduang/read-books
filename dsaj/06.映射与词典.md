# 06.映射与词典

标签（空格分隔）： 数据结构与算法

---

<font color="FF2D2D">映射和词典</font>这两种数据结构就是通过关键码来查找数据并对其进行操作的典型例子。

与优先队列一样，映射和词典中存放的元素也是一组由关键码和数据合成的条目。这两者中条目的区别：

 - 映射要求不同条目的关键码各不相同；

 - 词典则允许不同条目拥有相同的关键码，与优先队列不同的是词典不要求条目之间进行排序，如果词典中的条目之间具有某种顺序关系，此时的词典称为有序词典。

## 映射（Map）

映射（Map）也是一种存放一组条目的容器。与优先队列一样，映射中的条目也是形如(key, value)的组合对象，其中key为关键码对象，value为具体的数据对象；在映射中，各条目的关键码<font color="FF2D2D">不允许重复冗余</font>。

映射中的元素由其关键码唯一标识，而且映射的作用就是通过关键码直接找到对应的元素，故不妨就把关键码理解为指向对应元素的<font color="FF2D2D">“地址引用”</font>。

### 映射ADT

| 操作方法    | 描述                                                     |
| ----------- | -------------------------------------------------------- |
| size()      | 返回映射的规模                                           |
| isEmpty()   | 判断映射是否为空                                         |
| get(key)    | 根据key获取映射中所对应条目的value，如果不存在就返回null |
| put(k, v)   | 将条目(k, v)加入到映射中，如果存在key相同的条目就覆盖    |
| remove(key) | 根据key移除条目并返回value，如果不存在就返回null         |
| entries()   | 返回映射中所有条目的一个迭代器                           |

映射的接口定义：

```
public interface DSAMap<K, V> {

	// 查询映射结构当前的规模
	public int size();

	// 判断映射结构是否为空
	public boolean isEmpty();

	// 若映射中存在以key为关键码的条目，则返回该条目的数据对象；否则，返回null
	public V get(K key);

	// 若映射中不存在以key为关键码的条目，则插入条目(key, value)并返回null
	// 否则，将已有条目的数据对象替换为value，并返回原先的数据对象
	public V put(K key, V value);

	// 若映射中存在以key为关键码的条目，则删除之并返回其数据对象；否则，返回null
	public V remove(K key);

	// 返回映射中所有条目的一个迭代器
	public DSAIterator<DSAEntry<K, V>> entries();

}
```

### 判等器

由于映射结构必须能够比较任意一对关键码是否相等，每个映射结构在被创建的时候，都需要指定某一具体标准，以便进行关键码的比较，所以就需要抽象出判等器类。

定义判等器接口：

```
public interface Equality<E> {

	public boolean isEqualTo(E a, E b);//若a与b相等，则返回true；否则，返回false
	
}
```

由于Java中所有对象本身都已经提供了一个判等方法equals()，所以在实现默认判等器的时候可以这样做：

```
public class DefaultEquality<E> implements Equality<E> {

	@Override
	public boolean isEqualTo(E a, E b) {
		if (a == null) {
			return false;
		}
		return a.equals(b);
	}

}
```

### java.util.Map

Java在java.util包中已定义了一个名为java.util.Map的映射接口，但是java.util.Map接口不使用外部判等器，而是直接使用Object自带的equals()方法进行判等，这样做有如下缺点：

 - 一旦默认的equals()方法对java.util.Map中存放的对象不适用，我们只好去修改关键码类本身———这有悖于面向对象编程的封装原则；

 - 即使是同一类对象，在不同场合中判等的具体标准也可能不尽相同，不是一成不变的。

## 散列表

如果将条目的关键码视作其在映射结构中的存放位置，则可以通过散列表（HashTable）的形式来实现映射结构。

散列表由两个要素构成：<font color="FF2D2D">桶数组与散列函数</font>。

### 桶及桶数组

散列表使用的桶数组（BucketArray），其实就是一个容量为N的普通数组A[0..N-1]，只不过在这里，我们将其中的每个<font color="FF2D2D">单元都想象为一个“桶”（Bucket）</font>，每个桶单元里都可以存放一个条目。

但是既然选用了数组，那么就会很难确定数组的最佳容量 N，故往往选用远大于映射实际规模 n 的某个 N；而且数组都是通过索引来获取、新增、删除、修改元素，而索引是正整数类型的，但是条目中的key不一定是正整数，还可能是十分复杂的对象，为了解决这个问题，我们需要一个函数，可以<font color="FF2D2D">将任意的key转换为介于0到N-1之间的整数</font>————这个函数就是散列函数（Hash Function）。

### 散列函数

散列函数将关键码key映射为一个整数h(key)∈[0..N-1]，并将对应的条目存放至第h(key)号桶内，其中N为桶数组的容量。如果将桶数组记作A[]，这一技术就可以总结为“将条目e=(key,value)存放至A[h(key)]中”。反过来，为了查找关键码为ey的条目，只需取出桶单元A[h(key)]中存放的对象。因此，h(key)也被称作 e 的散列地址。

因为映射中单元不能重复所以需要满足：不同的关键码<font color="FF2D2D">key1≠key2</font>必然对应于不同的散列地址<font color="FF2D2D">h(key1)≠h(key2)</font>。对于<font color="FF2D2D">不同key的散列地址却相同</font>的这一现象我们称为散列冲突（HashCollision）。

虽然有解决散列冲突的办法，但与其坐等冲突的发生还不如首先在设计上和选择散列函数时多下点功夫，尽可能低的降低发生冲突的概率。

一个好的散列函数，应该满足两条基本要求：

 - h()应该尽可能接近单射，单射的意思就是不同的key得到的地址都不一样；

 - 对于任何关键码 key，h(key)的计算必须能够在O(1)时间内完成。

### 散列码

将任意类型的关键码key转换后得到整数，称作key的散列码（HashCode）；但是散列码距离我们最终所需的散列地址还有很大距离———散列码不见得落在区间[0..N-1]内，甚至不见得是正的整数。不过在关键码转换为散列码的过程中我们更应该关心：各关键码的散列码之间，应尽可能地减少冲突。显然，要是在这一阶段就发生冲突，后面的冲突就无法避免。

对于散列码的计算，一般分为两步：

 1. 将一般性的关键码key转换为一个称作“散列码”的整数；

 2. 通过所谓的“压缩函数”将该整数映射至区间[0..N-1]内。

![散列码的计算][1]

  [1]: https://img.alicdn.com/imgextra/i2/2462471552/TB2XFGWaGi5V1BjSspiXXXGBFXa_!!2462471552.png
  
Java中的Object提供一个默认的散列函数hashCode()，利用它可以将任意对象实例映射为“代表”该对象的某个整数。具体来说，hashCode()方法的返回值是一个32位int型整数。实际上，这一默认 hashCode()方法所返回的就是对象在内存中的存储地址。

不同的数据类型，散列方法也是不同的：

 - 对于那些不会超过32位的数据类型（Java中的byte、short、int和char），我们可以直接用它们的值来作为散列码。为此，我们只需通过类型强制转换，将它们转化为32bit的整数；
 
 - 对于float类型，可以通过Float.floatToIntBits(float)将返回的整数作为散列码；
 
 - 对于long和double这类长度为64位的基本类型，可以将高32位和低32位分别看做两个32位整数，然后再取二者之和的低32位作为散列码。相应的实现如下：
 
```
int hash64bit(long i){// 或double
	// long和double是64位，这里i>>32指的是取64位中的高（左）32位，(int)i是取低（右）32位，然后将两者相加的结果再取低32位用于当做散列码
	return (int) ((i>>32) + (int) i); 
}
```

 - 对于String类型，可以看做是由多个字符组合而成的对象，但是我们不能简单地将各字符对应的整数之和作为散列码，否则会造成散列冲突，因为同样多的字符可以组装成不同的字符串（如：step和pets）；为此我们可以取一个整数x（≠0、≠1），比如字符串"abc"，可以取其散列码为：a*x^n-1+b*x^n-2+c*x^n-3其中n为字符串的长度，这种散列码我们称之为<font color="FF2D2D">多项式散列码</font>；整数x的选取很有讲究，因为这种多项式散列码不可避免的会出现数值溢出，所以整数x本身的低位不能为零，经实验表明：对于英语单词之类的字符串，a = 33、37、39 或 41 都是不错的选择。
 
 - 上诉多项式散列码的一个明显不足在于计算复杂，对该方法的一种改进，就是利用<font color="FF2D2D">循环移位来模拟乘法运算的效果</font>。具体的实现如下所示：
 
```
int hashPolynomial(String s) {
	int h = 0;
	for (int i = 0; i < s.length(); i++) {
	    // 循环左移 5 位，对于英语单词来说，这也是通过实验统计得出的最佳值
		h = (h << 5) | (h >> 27);
		h += (int) s.charAt(i);
	}
	return h;
}
```

### 压缩函数

在将不同对象转化为散列码之后，我们需要将其压缩到我们希望的[0...N-1]区间内。

 - 模余法：最简单的压缩方法，将散列码映射为|i| % N（N为素数），但还是会发生冲突；
 
 - MAD法：一种将乘法（Mutiply）、加法（And）、除法（Divide）结合起来的方法，该方法的名称也是由此而来的： |a * i + b| % N（N为素数），且a > 0、b > 0，a % N ≠ 0。

### 冲突的普遍性————生日悖论

散列表的基本思想，是采用一个桶数组A[]，然后借助一个散列函数h()，根据条目(key,value)的关键码 key 直接得到其对应的桶单元编号A[h(key)]，从而快速地完成访问与修改。然而遗憾的是，很难保证不同关键码所对应的桶编号不致冲突。实际上，不发生任何冲突的概率是非常小的。

### 解决冲突

分离链解决散列冲突，就是当发生冲突时，桶数组中的一个桶存放多个冲突的条目（桶数组 + 列表）。

解决散列冲突还有很多办法，不过由大量的是实验证明：分离链策略的时间效率要远远高于其它的方法。因此，除非在存储空间非常紧张的场合，我们都建议采用分离链策略解决冲突。

### 装填因子

对于散列表的性能而言，装填因子λ=n/N是最重要的影响因素。如果λ>1，则冲突在所难免。实际上，关于散列表平均复杂度的分析结果指出，采取分离链策略时应该保持λ < 0.9。

若采用分离链策略，则在发生冲突的桶中，对条目的查找将退化为对链表的查找。因此，随着λ不断接近于1，发生冲突的概率也将不断接近于100%，从而导致更多的时间消耗于对链表的查找，使得各种操作的效率下降。在最坏的情况下，几乎所有的条目都聚集在同一个桶中。此时，对映射结构的操作将退化为对单一链表的操作，因此每次操作都需要 O(n)时间。

### 重散列

rehash：<font color="FF2D2D">将所有条目全部取出，将桶数组的规模加倍，然后将各条目重新插入其中</font>。

JDK中内置的java.util.HashMap类，在创建该对象的实例时，我们可以指定装填因子的上限（默认设置为 0.75），一旦超出就会进行rehash。

实验表明，经过重散列之后，原先聚集的条目一般都会比较均匀地分散开。





