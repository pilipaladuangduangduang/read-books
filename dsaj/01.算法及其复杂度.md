# 01.算法及其复杂度

标签（空格分隔）： 数据结构与算法

---

## 排序的重要性

据统计，计算机中80%的工作都是在排序。

### 冒泡排序

在由一组元素组成的序列A[0..n-1]中，若任意一对相邻元素A[i-1]和A[i]满足A[i-1]<=A[i]，就称该序列是顺序的，否则就是乱序的；排序的目的就是通过交换元素的位置，使得所有相邻元素都是顺序的。

冒泡排序的分析过程：

<font color="FF2D2D">输入</font>：n个元素组成的一个序列A[]，每个元素由[0..n-1]之间的下标确定，元素之间可以比较大小；

<font color="FF2D2D">输出</font>：重新调整A[]中元素次序，使得元素们按照非降次排序；

<font color="FF2D2D">过程</font>：

 1. 从A[0]开始，依次检查每一对相邻的元素；

 2. 只要他们位置颠倒，则交换其位置；

 3. 反复执行上诉操作，直到每一对相邻元素的次序都符合要求。
 
冒泡排序的代码实现：

``` java
/**
 * 冒泡排序的两种实现：递归冒泡、普通冒泡
 * 经过测试，发现递归冒泡的效率要比普通冒泡高，不过当序列元素太多时会栈溢出
 */
public class BubbleSorter {

    /**
     * @desc   递归实现冒泡排序
     * @param  ts    需要被排序的数组
     * @param  tsLen 需要被排序的数组长度
     * @param  <T>   数组的元素是需要继承Comparable类的，以便于compareTo
     * @return 排序后的数组
     */
    public static <T extends Comparable<? super T>> T[] recursiveBubbleSort(T[] ts, int tsLen) {

        // 定义递归的出口，也就是数组中只剩最后一个元素
        if (tsLen <= 1) {
            return ts;
        }

        for (int i = 0; i < tsLen - 1; i++) {
            // compareTo返回0时表示两个元素相等，返回负数表示前者小于后者，返回正数表示前者大于后者
            if (ts[i].compareTo(ts[i + 1]) > 0) {
                T temp = ts[i];
                ts[i] = ts[i + 1];
                ts[i + 1] = temp;
            }

        }
        // 递归冒泡，每递归一次，数组的长度“减一”，因为最后一个元素已经被确定了就无需进行比较了
        recursiveBubbleSort(ts, tsLen - 1);
        return ts;
    }

    /**
     * @desc   普通的冒泡排序，耗时相对高
     * @param  ts 需要被排序的数组长度
     * @param  <T> 数组的元素是需要继承Comparable类的，以便于compareTo
     * @return 排序后的数组
     */
    public static <T extends Comparable<? super T>> T[] bubbleSort(T[] ts) {

        int len = ts.length;
        if (len <= 1) {
            return ts;
        }

        // 冒泡排序至多经过和自身长度一致的排序次数，所有元素都将实现完全有序
        for (int i = 0; i < len - 1; i++) {
            // 每次冒泡之后，最后的一个元素就无需比较了
            for (int j = 0; j < len - 1 - i; j++) {
                if (ts[j].compareTo(ts[j + 1]) > 0) {
                    T temp = ts[j];
                    ts[j] = ts[j + 1];
                    ts[j + 1] = temp;
                }
            }
        }
        return ts;
    }

    // ------- 实验讲堂：经过测试发现，递归冒泡的效率要比普通冒泡高~不过，当序列中元素个数过多的时候，使用递归冒泡就会stackoverflow
}
``` 

冒泡排序原理：利用冒泡排序算法对长度为n的序列进行排序，<font color="FF2D2D">最多</font>经过n轮扫描交换后，所有元素都将实现完全有序。

## 算法的定义

所谓算法，就是在特定的计算模型下，在信息处理过程中为<font color="FF2D2D">解决某一类问题</font>而设计的一个指令序列。

### 算法必备的要素

 - <font color="FF2D2D">输入</font>：待处理的信息、即对具体问题的描述；

 - <font color="FF2D2D">输出</font>：经过处理之后得到的信息，即问题的答案；

 - <font color="FF2D2D">确定性</font>：任一算法都可以描述为由若干种基本操作组成的序列；

 - <font color="FF2D2D">可行性</font>：在相应的计算模型中，每一种基本操作都可以实现，且能够在常熟时间内完成；

 - <font color="FF2D2D">有穷性</font>：对于任何输入，按照算法，经过有穷次基本操作都可以得到正确的输出。
 
## 算法的性能分析

在编写代码过程中，我们不仅希望算法对任何输入都能够在有穷次操作后终止并输出结果，而且希望等待的时间<font color="FF2D2D">尽可能的短</font>。

### 时间复杂度

针对时间复杂度，我们只需要考虑算法中的<font color="FF2D2D">输入</font>这一因素，相对于同一个算法，输入序列的规模不同，而导致处理的时间也大大不同。所以关于时间复杂度问题我们可以抽象为：<font color="FF2D2D">针对不同规模的输入，算法的执行时间各为多少？</font>

如果将某一算法为了处理规模为n的问题所需的时间记作T(n)，那么随着n的增长，运行时间T(n)将如何增长？<font color="FF2D2D">T(n)</font>就是算法的时间复杂度。

往往在评价算法的运行时间时，我们都是忽略输入规模较小时的情况，转而关注输入规模足够大的情况，因为不同算法在<font color="FF2D2D">处理规模较小时差异不是很明显</font>。

然而，在实际的计算环境中，关于时间复杂度T(n)依然无法度量，即便是同一算法、同一输入，在不同的硬件平台上、使用不同的操作系统所需要的计算时间都不相同；不过这种情况依然有相应的解决办法，就是将我们的关注点从<font color="FF2D2D">算法的执行时间上转移到算法执行的次数上</font>，也就是用次数来表示时间复杂度T(n)。

T(n) = O(f(n))，算法的时间复杂度增长级别，如下表所示：

| 增长级别   | 描述         | 举例说明     |
| ---------- | ---------    | ------------ |
| O(1)       | 常数级别     | 两个数相加   |
| O(log n)   | 对数级别     | 二分法       |
| O(n)       | 线性级别     | 一层for循环  |
| O(n log n) | 线性对数级别 | 归并排序     |
| O(n^2)     | 平方级别     | 二层for循环  |
| O(n^3)     | 立方级别     | 三层for循环  |
| O(2^n)     | 指数级别     | 穷举法       |

### 空间复杂度

衡量算法性能的另一个重要方面，就是算法所需使用的存储空间量，即算法的空间复杂度。显然对于同样的输入规模，同样时间复杂度的前提下，算法所占用的空间越少越好。

不过，在通常情况下，我们都更多地分析和讨论算法的时间复杂度，甚至<font color="FF2D2D">只关注时间复杂度</font>。

## 递归

递归是高级程序设计语言的一个重要特征，它允许程序中的函数进行自我调用；还有另一种形式的递归：函数M不直接调用自身，而是调用别的函数，别的函数中又间接的调用函数M。

在现代操作系统中，文件系统的目录结构就是递归定义的。具体来说，每个文件系统都有一个最顶层的目录，其中可以包含若干文件和下一层的子目录；在每个子目录中，也同样可能包含若干文件和再下一层的子目录；如此下去文件系统中的目录就可以嵌套任意多层（只要系统的存储资源足以支持）。 

递归一般分为线性递归、二分递归、多分支递归等。

### 线性递归

线性递归是最简单的递归形式，这类方法的每个实例只能递归地调用自己至多一次。

数组元素的递归求和：

``` java
/**
 * @desc      递归的求数组中元素之和
 * @param arr 需要被求和的数组
 * @param len 数组的长度
 * @return    数组中元素的总和
 */
public static Integer LinearSum(Integer[] arr,Integer len) {
    // 递归的方法必须要有出口
    if (len == 1) {
        return arr[0];
    }
    // 元素从大到小的依次相加，该递归非尾递归，虽然递归调用在方法体的末尾，但是最后一次操作是相加操作
    return LinearSum(arr, len - 1) + arr[len - 1];
}
``` 

递归实现数组元素的倒置：

``` java
/**
 * @desc      递归颠倒数组中元素
 * @param arr 需要被颠倒的数组
 * @param low 元素所在数组中的起点索引
 * @param hi  元素所在数组中的终点索引
 */
public static void ReverseArray(Integer[] arr, Integer low, Integer hi) {
    if(low > hi) {
        return;
    }
    // 交换元素位置
    swap(arr, low, hi);
    // 再次调用时，数组中已经交换了位置的元素就无需进行处理了，该递归是尾递归
    ReverseArray(arr, ++low, --hi);
}

private static void swap(Integer[] arr, Integer low, Integer hi) {
    Integer temp = arr[low];
    arr[low] = arr[hi];
    arr[hi] = temp;
}
``` 

从上诉例子可以看出递归方法的两条重要性质：

 - 经过有限的时间后，它必须能够终止；

 - 随着递归的深入，调用的参数将单调递减。

在设计递归算法时，应该从各种角度来考虑对问题的划分，重新对问题做出定义，使得分解后的子问题与原问题具有相同的结构。

#### 尾递归？？

在线性递归算法中，若递归调用恰好出现在算法的<font color="FF2D2D">最后一次操作</font>，我们就称之为尾递归。

不过需要注意，即使递归调用语句出现在方法体的最后一行，也不见得就是尾递归。严格地说，在最后的一次操作中只有递归操作才属于尾递归：<font color="FF2D2D">数组中元素递归求和</font>就不是尾递归，虽然递归调用语句在方法的最后一行，但是最后一次操作是相加操作。
 
只要将尾递归改写为迭代形式，就可以将其转化为功能相同的非递归算法。

迭代方式进行数组元素的颠倒：

``` java
/**
 * @desc      将尾递归改为迭代的形式
 * @param arr 需要被颠倒的数组
 * @param low 元素所在数组中的起点索引
 * @param hi  元素所在数组中的终点索引
 */
public static void IterativeReverseArray(Integer[] arr, Integer low, Integer hi) {
    while(low < hi) {
        swap(arr, low, hi);
        ++low;
        --hi;
    }
}

private static void swap(Integer[] arr, Integer low, Integer hi) {
    Integer temp = arr[low];
    arr[low] = arr[hi];
    arr[hi] = temp;
}
``` 

### 二分递归

有的时候，算法需要将一个大问题分解为两个子问题，然后分别通过递归调用来求解，这种情况称作二分递归（Binary recursion ）。

通过二分递归计算 Fibonacci：

``` java
/**
 * 利用二分递归求Fibonacci数，但是这是一个指数复杂度的算法，在实际环境中毫无用处
 * 		Fibonacci：指的是这样一个数列：0、1、1、2、3、5、8、13、21、34...
 * 		这个数列从第2项开始，每一项都等于前两项之和。
 * 		第0项是0，第1项是第一个1，以此类推
 * @param  k 数列中的第几项
 * @return 数列中第几项所对应的值，如：第0项是0，第3项是2，第7项是13
 */
public static int binaryFib(int k) {
	if (k <= 1)
		return k;
	else
		return binaryFib(k - 1) + binaryFib(k - 2);
}
``` 

虽然二分递归可以求出Fibonacci数，但是该算法的时间复杂度是指数级别的，在实际环境中毫无用处。

动态规划：把子问题的计算结果记录下来，此后若再次遇到相同的子问题，就可以根据记录直接获得结果，而不必重新计算。

### 多分支递归

有的时候，一个问题可能需要分解为不止两个子问题，此时就要采用多分支递归（Multiple recursion）。

作者水平有限，实在看不懂。。。

## 递归算法的复杂度分析

### 递归跟踪法

递归跟踪是一种直观的、可视的分析方法，它可以帮助我们分析递归算法的运行时间。所谓递归跟踪法，就是将递归方法的执行过程表示为<font color="FF2D2D">图形</font>的形式：方法的每一实例都对应于一个方框，其中注明了该实例调用的参数；若方法实例M调用方法实例N，则在M与N对应的方框之间添加一条有向联线，指明调用与被调用的关系。

下图就利用递归跟踪法对数组中元素递归求和算法做一分析：

![递归跟踪法][1]

[1]: https://img.alicdn.com/imgextra/i3/2462471552/TB2g8aXX37c61BjSZFKXXb6hFXa_!!2462471552.png

从图可以得知，算法的运行时间实质消耗于各方法实例的<font color="FF2D2D">非递归部分</font>（如果忽略系统为实现递归而消耗的时间）。在每一次调用中，非递归部分处理（在此前的部分和的基础上，累计下一整数）均只需常数时间。对于规模为n的数组，递归的深度显然为n，因此算法LinearSum需要运行n × O(1) = O(n)时间。

### 递推方程法

对递归算法做复杂度分析的另一种常用方法，就是递推方程法。与递归跟踪法相反，这种方法并不直观，而是通过对递归的模式进行归纳从而导出关于复杂度函数的递推方程，递归方程的解将给出算法的复杂度。这一方法的思路与<font color="FF2D2D">微分方程法</font>极其相似：对于一些极为复杂的函数，我们并不能立即给出其显式的表示，但是它们的微分形式却可能会满足相对简单的方程，通过这种微分方程，我们可以最终导出原函数的显式表示。通常，微分方程的解并不唯一，除非给定一些边界条件。类似地，为了使复杂度函数的递推方程能够给出确定的解，也需要给定某些边界条件这一任务由<font color="FF2D2D">递归基完成</font>。 

下面也是以LinearSum函数来进行递推分析：

首先，我们将LinearSum()在处理规模为n的数组时所需的运行时间记作T(n)， 

然后，为了求解问题LinearSum(A,n)，我们递归地求解问题LinearSum(A,n-1)，然后再累计上A[n-1]；

最后，求解问题LinearSum(A,n)所需的时间，应该等于求解LinearSum(A,n-1)的时间，再加上一次加法所需的时间。

T(n)  =   T(n-1) + O(1)  =   T(n-1) + c1，c1为常数 

当抵达递归基时，求解问题 LinearSum(A, 1)只需常数时间，即 

T(1)  =   O(1)  =   c2，c2为常数

综上所述：

T(n)  =   c1(n-1) + c2  =  c1(n) + (c2 – c1)  =   O(n) 


