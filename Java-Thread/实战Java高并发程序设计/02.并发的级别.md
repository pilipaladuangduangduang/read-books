# 02.并发的级别

标签（空格分隔）： Redis-In-Action

---

由于临界区的存在，多线程之间的并发必须受到控制，根据控制并发的策略，可以把并发的级别进行分类，大致可分为：阻塞、无饥饿、无障碍、无锁、无等待。

## 阻塞（Block）

一个线程是阻塞的，那么在其他线程释放资源之前，当前线程是无法继续执行的。

我们可以使用synchronized关键字或重入锁就可以得到阻塞的线程。

## 无饥饿（Starvation-Free）

由于线程之间是有优先级的，那么在资源分配的时候总是优先满足级别高的线程（可以理解成插队）。

我们可以使用公平锁来实现无饥饿，由于锁是公平的，满足先来后台的执行顺序，饥饿就不会产生，无论新来的线程优先级有多高，都得乖乖排队。

## 无障碍（Obstruction-Free）

无障碍是一种最弱的非阻塞调度。

多个线程如果是无障碍执行，就可以同时访问临界区的资源，也就可以同时修改同一资源，只不过一旦发生了这种情况线程就会进行回滚，如果没有数据发生竞争就不会回滚。

阻塞的控制方法是悲观策略，它认为多线程之间很有可能发生冲突，因此以保护共享数据为第一优先级。

无障碍的控制方法是乐观策略，它认为多线程之间发生冲突的几率不大，发生冲突的时候回滚就行了。

我们可以依赖一个“一致性标记”来实现无障碍，线程在操作之前，先读取并保存这个标记，在操作完后，再次读取，检查这个标记是否被更改过，如果两者一致的，则说明资源访问没有冲突。如果不一致说明发生了冲突，就需要回滚了，且任何对资源有修改操作的线程，在修改数据前，都需要更新“一致性标记”，告诉其他线程这个数据是不安全的。

## 无锁（Lock-Free）

无锁的多线程都是无障碍的，但需要保证必然有一个线程能够在有限时间内完成操作并离开临界区。

无锁的调用中，常常通过无限循环来实现。

## 无等待（Wait-Free）

无等待的要求要比无锁高，无等待要求所有线程在有限时间内都必须完成操作并离开临界区。

一种典型的无等待结构就是RCU（Read-Copy-Update），基本思想就是对数据的读不加限制，因此所有的读线程都是无等待的，在写数据的时候，先将数据复制一份，接着只修改复制后的数据，修改后，在合适的时机回写数据。