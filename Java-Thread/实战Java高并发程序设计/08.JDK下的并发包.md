# 08.JDK提供的并发包

标签（空格分隔）：实战Java高并发程序设计

---

为了更好的写好并发程序，JDK内部提供了类库的支持。

## 同步控制

同步控制是并发程序必不可少的手段。其中，synchronized是一种最简单的控制方法。

### 重入锁

synchronized的替代品：重入锁；在JDK1.5之前，重入锁的性能要好于synchronized，但在JDK1.6之后进行了优化，使得两者性能相差无几。

重入锁是使用java.util.concurrent.locks.ReentrantLock来实现的：

``` java
// 重入锁
static ReentrantLock lock = new ReentrantLock();

static int i = 0;

public void run() {
    for (int j = 0; j < 10000; j++) {
        lock.lock();
        try{
            i++;
        } finally {
            // 释放重入锁
            lock.unlock();
        }
    }
}
```

什么时候获取锁，什么时候释放锁，都由开发人员自己控制的，所以要比synchronized关键字灵活。

重入锁中的重入该怎么解释呢：这种锁是可以反复进入的，不过反复进入只限于一个线程。

``` java
// 一个线程可以获取多把重入锁
lock.lock();
lock.lock();
lock.lock();
try{
    i++;
} finally {
    // 获取到几把锁，就要释放掉几把
    lock.unlock();
    lock.unlock();
    lock.unlock();
}
```

重入锁还可响应中断线程的操作：如果一个线程在等待锁，可以收到一个通知，被告知无须再等待，可以停止工作了。

``` java
// 重入锁
static ReentrantLock lock = new ReentrantLock();
static ReentrantLock lock0 = new ReentrantLock();

boolean flag;

MyThread(boolean flag){
    this.flag = flag;
}

public void run() {

    try {
        if(flag) {
            // lockInterruptibly()可以对中断操作进行响应
            lock.lockInterruptibly();
            Thread.sleep(5000);
            lock0.lockInterruptibly();
            System.out.println(Thread.currentThread().getName() + "<--线程完成了任务");
        } else {
            lock0.lockInterruptibly();
            Thread.sleep(5000);
            lock.lockInterruptibly();
            System.out.println(Thread.currentThread().getName() + "<--线程完成了任务");
        }

    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if(lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
        if(lock0.isHeldByCurrentThread()) {
            lock0.unlock();
        }

    }

}

Thread t = new Thread(new MyThread(false), "t");
Thread t0 = new Thread(new MyThread(true), "t0");

t.start();
t0.start();
// 此时t线程获取了lock0重入锁等待着lock重入锁
// 此时t0线程获取了lock重入锁等待着lock0重入锁
// 线程t和t0造成了死锁
Thread.sleep(10000);
// t0中断了操作，不再等待lock0重入锁，同时释放了lock重入锁，并且线程t获取到了lock重入锁从而完成了任务
t0.interrupt();
```

控制台输出：

``` java
// t0线程进行了中断操作
java.lang.InterruptedException
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)
	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)
	at MyThread.run(MyThread.java:25)
	at java.lang.Thread.run(Thread.java:745)
Disconnected from the target VM, address: '127.0.0.1:60671', transport: 'socket'
// 只有t线程完成了任务
t<--线程完成了任务
```

请求重入锁设置等待时间

``` java
// 此时这里表示的是线程只等待重入锁5秒钟，超时就放弃等待返回flase
boolean flag = lock.tryLock(5, TimeUnit.SECONDS);
// 不带参数调用时，表示线程抢到锁就成功返回true，抢不到立即返回false不会进行等待
lock.tryLock();
```

### 公平锁

当我们使用synchronized关键字进行锁控制时，产生的锁是不公平的，不会遵循先来后到的规则。

重入锁可以进行设置锁的公平性

``` java
// 将重入锁变成公平锁，重入锁有一个构造器用于设置，fair为true时就是公平的
// 实现公平锁，就会需要一个有序的队列，因此公平锁的性能会相对低下
public ReentrantLock(boolean fair);
static ReentrantLock lock = new ReentrantLock(true);
```

### 重入锁中重要的API

``` java
lock();// 获得锁，如果锁被占用就等待
lockInterruptibly();// 获得锁，能够响应中断操作
tryLock()// 获得锁，如果锁被占用不会等待
tryLock(long time, TimeUnit unit);// 获得锁，如果锁被占用等待指定的时间
unlock();// 释放锁
```

### 重入锁的好搭档：Condition

Object.wait()和Object.notify()与synchronized关键字配合使用可以进行线程调度；同样的，Condition和ReetrantLock两者之间也可以进行线程调度而且更方便。

``` java
// 重入锁
static ReentrantLock lock = new ReentrantLock();
// condition是通过重入锁new出来的
static Condition condition = lock.newCondition();

public void run() {

    try {
        // 抢占到重入锁
        lock.lock();
        // 线程在condition队列中进行等待，同时会释放重入锁
        condition.await();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }

}

public static void main(String[] args) throws Exception {

    Thread t = new Thread(new MyThread());
    t.start();
    Thread.sleep(2333);
    // 因为t线程在condition队列中等待了，所以main线程可以抢占到重入锁
    lock.lock();
    // 唤醒condition队列中的任意线程
    condition.signal();
    // main线程释放重入锁，重新还给t线程，使得t线程可以继续执行
    lock.unlock();
}

```

在JDK中，重入锁和Condition被广泛的使用如：ArrayBlockingQueue...

## 允许多个线程同时访问：Semaphore

像synchronized关键字和可重入锁，都是一次只允许一个线程访问同一资源，而Semaphore却允许多个线程（可以指定线程个数）同一访问同一资源。

``` java
// 指定可以同时访问的线程个数
public Semaphore(int permits);
// 指定个数，并可设置是否公平
public Semaphore(int permits, boolean fair);
```

Semaphore的简单demo

``` java
// 申明可以同时又7个线程访问临界区的代码
final Semaphore semaphore = new Semaphore(7);

public void run() {

    try {
        // 和重入锁的lock()类似
        semaphore.acquire();
        // 模拟业务操作
        Thread.sleep(2333);
        System.out.println(Thread.currentThread().getId() + "done~");

    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        // 和重入锁的unlock()类似
        semaphore.release();
    }

}

public static void main(String[] args) throws InterruptedException {
    ExecutorService exe = Executors.newFixedThreadPool(21);
    final MyThread t = new MyThread();
    for (int i = 0; i < 21; i++) {
        exe.submit(t);
    }
}
```

## 读写锁ReadWriteLock

读写锁为了解决读-读线程之间不用阻塞的问题，读-写和写-写还是需要阻塞的。

如果在系统中，读的操作次数远大于写的操作次数，那么读写锁就可以发挥最大的功效，提升系统的性能。

``` java
// API的使用和重入锁类似
static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
rwl.readLock();
rwl.writeLock();
```

## 任务计数器：CountDownLatch

当某些子任务完成的时候，主任务才开始工作。

``` java
// 当7个子任务完成的时候，某个主任务才开始
static CountDownLatch end = new CountDownLatch(7);

public void run() {

    try {
        // 模拟业务操作
        Thread.sleep(2333);
        // 一个任务完成了就减一
        end.countDown();

    } catch (Exception e) {
        e.printStackTrace();
    } 

}

public static void main(String[] args) throws InterruptedException {
    ExecutorService exe = Executors.newFixedThreadPool(7);
    final MyThread t = new MyThread();
    // 开启7个任务
    for (int i = 0; i < 7; i++) {
        exe.submit(t);
    }
    // 7个任务都完成了，才继续
    end.await();
    exe.shutdown();
}
```

## 循环任务计数器：CyclicBarrier

功能和CountDownLatch类似，可以实现线程间的计数等待，而且可以循环使用。

``` java
// 第一个参数是指定完成任务的个数，第二个参数是在全部任务完成之后会做的任务
static CyclicBarrier end = new CyclicBarrier(7, new Runnable() {
    public void run() {
        // 子任务做完，就做这个任务，可以循环
    }
});

public void run() {

    try {
        // 先进行检查子任务
        doCheck();
        // 检查子任务全部完毕之后，会做自己的一个任务
        end.await();
        // 再进行干活
        doWork();
        // 可以循环操作
        end.await();

    } catch (Exception e) {
        e.printStackTrace();
    }

}

public static void main(String[] args) throws InterruptedException {
    ExecutorService exe = Executors.newFixedThreadPool(7);
    final MyThread t = new MyThread();
    // 开启7个任务
    for (int i = 0; i < 7; i++) {
        exe.submit(t);
    }
    exe.shutdown();
}

```

## 线程阻塞工具类：LockSupport

LockSupport可以在线程内任意位置让线程阻塞

``` java
// park()使得当前线程阻塞
LockSupport.park();
// 解除某个线程的阻塞状态
LockSupport.unpark(Thread t);
```

## 线程复用：线程池